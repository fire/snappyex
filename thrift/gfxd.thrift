// ----------------------------------------------------------------
// Copyright (c) 2010-2015 Pivotal Software, Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License"); you
// may not use this file except in compliance with the License. You
// may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
// implied. See the License for the specific language governing
// permissions and limitations under the License. See accompanying
// LICENSE file.
// ----------------------------------------------------------------

// ----------------------------------------------------------------
// gfxd.thrift
//
// This is a Thrift interface definition file for the Pivotal GemFireXD service.
// Target language libraries for C++, Java, C#, Ruby, PHP, (and more) are
// generated by running this file through the Thrift compiler with the
// appropriate flags. The Thrift compiler binary and runtime
// libraries for various languages are available
// from the Apache Project (http://thrift.apache.org)
//
// ----------------------------------------------------------------

namespace java com.pivotal.gemfirexd.thrift
namespace cpp com.pivotal.gemfirexd.thrift
namespace csharp Pivotal.Data.GemFireXD.Thrift
namespace py gemfirexd
namespace rb GemFireXD
namespace php gemfirexd
namespace perl GemFireXD


enum FieldType {
  BOOLEAN           = 1
  BYTE              = 2
  SHORT             = 3
  INTEGER           = 4
  LONG              = 5
  FLOAT             = 6
  DOUBLE            = 7
  CHAR              = 8
  STRING            = 9
  DECIMAL           = 10
  TIMESTAMP         = 11
  BINARY            = 12
  REF               = 13
  BOOLEAN_ARRAY     = 14
  CHAR_ARRAY        = 15
  SHORT_ARRAY       = 16
  INT_ARRAY         = 17
  LONG_ARRAY        = 18
  FLOAT_ARRAY       = 19
  DOUBLE_ARRAY      = 20
  STRING_ARRAY      = 21
  ARRAY             = 22
  ARRAY_OF_BINARY   = 23
  PDX_OBJECT        = 24
  NATIVE_OBJECT     = 25
}

struct FieldDescriptor {
  1: required string    name,
  2: required FieldType type,
  3: optional bool      identity
}

struct Decimal {
  1: required byte   signum
  2: required i32    scale
  3: required binary magnitude
}

struct Timestamp {
  1: required i64 secsSinceEpoch,
  2: optional i32 nanos
}

struct FieldValue {
  1: optional bool             bool_val
  2: optional byte             byte_val
  3: optional i16              char_val
  4: optional i16              short_val
  5: optional i32              int_val
  6: optional i64              long_val
  // convert float to 4-bit integer first before writing
  7: optional i32              float_val
  8: optional double           double_val
  9: optional string           string_val
 10: optional Decimal          decimal_val
 11: optional Timestamp        timestamp_val
 12: optional list<bool>       bool_array
 13: optional binary           byte_array
 14: optional string           char_array
 15: optional list<i16>        short_array
 16: optional list<i32>        int_array
 17: optional list<i64>        long_array
 18: optional list<i32>        float_array
 19: optional list<double>     double_array
 20: optional list<string>     string_array
 21: optional list<binary>     byte_array_array
 22: optional i32              ref_val          // reference to PDXNode
 23: optional list<i32>        list_val         // array of PDXNodes
 24: optional binary           native_val       // native serialized object
 25: optional bool             null_val         // indicates that value is null
}

struct PDXNode {
  1: optional FieldValue       singleField     // for array
  2: optional list<FieldValue> fields
  3: optional i32              refId
}

struct PDXObject {
  1: optional list<FieldValue> fields    // optimization for flat objects
  2: optional list<PDXNode>    nodes     // all nodes in the object graph
}

struct PDXSchemaNode {
  1: optional FieldDescriptor       singleFieldDesc
  2: optional list<FieldDescriptor> fieldDescs
  3: optional i32                   refId
}

struct PDXSchema {
  1: required list<PDXSchemaNode> nodes  // all nodes in the object graph
}

struct JSONField {
  1: optional string    string_val
  2: optional bool      bool_val
  3: optional i32       i32_val
  4: optional i64       i64_val
  5: optional double    double_val
  6: optional bool      null_val
  7: optional i32       ref_val
  8: optional list<i32> array_val // of refIds
}

struct JSONNode {
  1: optional map<string, JSONField> pairs
  2: optional JSONField              singleField // for array
  3: required i32                    refId       // index in JSONObject
}

struct JSONObject {
   // list of all nodes; index into this should be the refId
  1: required list<JSONNode> nodes
}

struct BlobChunk {
  1: required binary chunk,
  2: required bool last,
  // optional when sending from client to server for update,
  // but required when returning from server to client or for gets
  3: optional i32 lobId,
  4: optional i64 offset,
  // total length of LOB; will be set for first chunk but optional for rest
  5: optional i64 totalLength
}

struct ClobChunk {
  1: required string chunk,
  2: required bool last,
  // optional when sending from client to server for update,
  // but required when returning from server to client or for gets
  3: optional i32 lobId,
  4: optional i64 offset,
  // total length of LOB; will be set for first chunk but optional for rest
  5: optional i64 totalLength
}

enum GFXDType {
  BOOLEAN           = 1
  TINYINT           = 2
  SMALLINT          = 3
  INTEGER           = 4
  BIGINT            = 5
  FLOAT             = 6
  REAL              = 7
  DOUBLE            = 8
  DECIMAL           = 9
  CHAR              = 10
  VARCHAR           = 11
  LONGVARCHAR       = 12
  DATE              = 13
  TIME              = 14
  TIMESTAMP         = 15
  BINARY            = 16
  VARBINARY         = 17
  LONGVARBINARY     = 18
  NULLTYPE          = 19
  OTHER             = 20
  JAVA_OBJECT       = 21
  DISTINCT          = 22
  STRUCT            = 23
  ARRAY             = 24
  BLOB              = 25
  CLOB              = 26
  REF               = 27
  DATALINK          = 28
  ROWID             = 29
  NCHAR             = 30
  NVARCHAR          = 31
  LONGNVARCHAR      = 32
  NCLOB             = 33
  SQLXML            = 34
  PDX_OBJECT        = 35
  JSON_OBJECT       = 36
}

// constants for StatementAttrs.resultSetType
const byte RESULTSET_TYPE_FORWARD_ONLY = 1;
const byte RESULTSET_TYPE_INSENSITIVE = 2;
const byte RESULTSET_TYPE_SENSITIVE = 3;
const byte RESULTSET_TYPE_UNKNOWN = 4;

// defaults for connection/statement attributes
const bool DEFAULT_AUTOCOMMIT = false;
const byte DEFAULT_RESULTSET_TYPE = RESULTSET_TYPE_FORWARD_ONLY;
const bool DEFAULT_RESULTSET_UPDATABLE = false;
const bool DEFAULT_RESULTSET_HOLD_CURSORS_OVER_COMMIT = false;

// additional flags for transactions
enum TransactionAttribute {
  AUTOCOMMIT = 1,
  READ_ONLY_CONNECTION = 2,
  WAITING_MODE = 3,
  DISABLE_BATCHING = 4,
  SYNC_COMMITS = 5
}

enum RowIdLifetime {
  // Indicates that this data source does not support the ROWID type.
  ROWID_UNSUPPORTED = 1,
  // Indicates that the lifetime of a RowId from this data source is
  // indeterminate; but not one of ROWID_VALID_TRANSACTION,
  // ROWID_VALID_SESSION, or, ROWID_VALID_FOREVER.
  ROWID_VALID_OTHER = 2,
  // Indicates that the lifetime of a RowId from this data source
  // is at least the containing session.
  ROWID_VALID_SESSION = 3,
  // Indicates that the lifetime of a RowId from this data source
  // is at least the containing transaction.
  ROWID_VALID_TRANSACTION = 4,
  // Indicates that the lifetime of a RowId from this data source
  // is, effectively, unlimited.
  ROWID_VALID_FOREVER = 5
}

enum ServiceFeature {
  ALL_PROCEDURES_CALLABLE = 1,
  ALL_TABLES_SELECTABLE = 2,
  INTEGRITY_ENHANCEMENT = 3,
  NULLS_SORTED_HIGH = 4,
  NULLS_SORTED_LOW = 5,
  NULLS_SORTED_START = 6,
  NULLS_SORTED_END = 7,
  USES_LOCAL_FILES = 8,
  USES_LOCAL_FILE_PER_TABLE = 9,
  MIXEDCASE_IDENTIFIERS = 10,
  MIXEDCASE_QUOTED_IDENTIFIERS = 11,
  STORES_UPPERCASE_IDENTIFIERS = 12,
  STORES_LOWERCASE_IDENTIFIERS = 13,
  STORES_MIXEDCASE_IDENTIFIERS = 14,
  STORES_UPPERCASE_QUOTED_IDENTIFIERS = 15,
  STORES_LOWERCASE_QUOTED_IDENTIFIERS = 16,
  STORES_MIXEDCASE_QUOTED_IDENTIFIERS = 17,
  ALTER_TABLE_ADD_COLUMN = 18,
  ALTER_TABLE_DROP_COLUMN = 19,
  COLUMN_ALIASING = 20,
  NULL_CONCAT_NON_NULL_IS_NULL = 21,
  CONVERT = 22,
  TABLE_CORRELATION_NAMES = 23,
  TABLE_CORRELATION_NAMES_DIFFERENT = 24,
  ORDER_BY_EXPRESSIONS = 25,
  ORDER_BY_UNRELATED = 26,
  GROUP_BY = 27,
  GROUP_BY_UNRELATED = 28,
  GROUP_BY_BEYOND_SELECT = 29,
  LIKE_ESCAPE = 30,
  MULTIPLE_RESULTSETS = 31,
  MULTIPLE_TRANSACTIONS = 32,
  NON_NULLABLE_COLUMNS = 33,
  SQL_GRAMMAR_MINIMUM = 34,
  SQL_GRAMMAR_CORE = 35,
  SQL_GRAMMAR_EXTENDED = 36,
  SQL_GRAMMAR_ANSI92_ENTRY = 37,
  SQL_GRAMMAR_ANSI92_INTERMEDIATE = 38,
  SQL_GRAMMAR_ANSI92_FULL = 39,
  OUTER_JOINS = 40,
  OUTER_JOINS_FULL = 41,
  OUTER_JOINS_LIMITED = 42,
  SCHEMAS_IN_DMLS = 43,
  SCHEMAS_IN_PROCEDURE_CALLS = 44,
  SCHEMAS_IN_TABLE_DEFS = 45,
  SCHEMAS_IN_INDEX_DEFS = 46,
  SCHEMAS_IN_PRIVILEGE_DEFS = 47,
  AUTOCOMMIT_FAILURE_CLOSES_ALL_RESULTSETS = 48,
  CATALOGS_IN_DMLS = 49,
  CATALOGS_IN_PROCEDURE_CALLS = 50,
  CATALOGS_IN_TABLE_DEFS = 51,
  CATALOGS_IN_INDEX_DEFS = 52,
  CATALOGS_IN_PRIVILEGE_DEFS = 53,
  POSITIONED_DELETE = 54,
  POSITIONED_UPDATE = 55,
  SELECT_FOR_UPDATE = 56,
  STORED_PROCEDURES = 57,
  SUBQUERIES_IN_COMPARISONS = 58,
  SUBQUERIES_IN_EXISTS = 59,
  SUBQUERIES_IN_INS = 60,
  SUBQUERIES_IN_QUANTIFIEDS = 61,
  SUBQUERIES_CORRELATED = 62,
  UNION = 63,
  UNION_ALL = 64,
  OPEN_CURSORS_ACROSS_COMMIT = 65,
  OPEN_CURSORS_ACROSS_ROLLBACK = 66,
  OPEN_STATEMENTS_ACROSS_COMMIT = 67,
  OPEN_STATEMENTS_ACROSS_ROLLBACK = 68,
  MAX_ROWSIZE_INCLUDES_BLOBSIZE = 69,
  TRANSACTIONS = 70,
  TRANSACTIONS_BOTH_DMLS_AND_DDLS = 71,
  TRANSACTIONS_DMLS_ONLY = 72,
  TRANSACTIONS_DDLS_IMPLICIT_COMMIT = 73,
  TRANSACTIONS_DDLS_IGNORED = 74,
  TRANSACTIONS_SAVEPOINTS = 75,
  CALLABLE_NAMED_PARAMETERS = 76,
  CALLABLE_MULTIPLE_OPEN_RESULTSETS = 77,
  GENERATED_KEYS_RETRIEVAL = 78,
  GENERATED_KEYS_ALWAYS_RETURNED = 79,
  BATCH_UPDATES = 80,
  RESULTSET_FORWARD_ONLY = 81,
  RESULTSET_SCROLL_INSENSITIVE = 82,
  RESULTSET_SCROLL_SENSITIVE = 83,
  RESULTSET_HOLDABILITY_CLOSE_CURSORS_AT_COMMIT = 84,
  RESULTSET_HOLDABILITY_HOLD_CURSORS_OVER_COMMIT = 85,
  LOB_UPDATES_COPY = 86,
  STATEMENT_POOLING = 87,
  STORED_FUNCTIONS_USING_CALL = 88
}

enum ServiceFeatureParameterized {
  TRANSACTIONS_SUPPORT_ISOLATION = 1,
  RESULTSET_TYPE = 2,
  RESULTSET_CONCURRENCY_READ_ONLY = 3,
  RESULTSET_CONCURRENCY_UPDATABLE = 4,
  RESULTSET_OWN_UPDATES_VISIBLE = 5,
  RESULTSET_OWN_DELETES_VISIBLE = 6,
  RESULTSET_OWN_INSERTS_VISIBLE = 7,
  RESULTSET_OTHERS_UPDATES_VISIBLE = 8,
  RESULTSET_OTHERS_DELETES_VISIBLE = 9,
  RESULTSET_OTHERS_INSERTS_VISIBLE = 10,
  RESULTSET_UPDATES_DETECTED = 11,
  RESULTSET_DELETES_DETECTED = 12,
  RESULTSET_INSERTS_DETECTED = 13
}

struct ServiceMetaData {
  1: required string productName,
  2: required string productVersion,
  3: required i32 productMajorVersion,
  4: required i32 productMinorVersion,
  5: required i32 jdbcMajorVersion,
  6: required i32 jdbcMinorVersion,
  7: required string identifierQuote,
  8: required list<string> sqlKeywords,
  9: required list<string> numericFunctions,
 10: required list<string> stringFunctions,
 11: required list<string> systemFunctions,
 12: required list<string> dateTimeFunctions,
 13: required string searchStringEscape,
 // none if not present
 14: optional string extraNameCharacters,
 // map of "fromType" to "toType"s supported by CONVERT function
 15: required map<GFXDType, set<GFXDType>> supportedCONVERT,
 16: required string schemaTerm,
 17: required string procedureTerm,
 18: required string catalogTerm,
 19: required string catalogSeparator,
 20: required i32 maxBinaryLiteralLength,
 21: required i32 maxCharLiteralLength,
 22: required i32 maxColumnsInGroupBy,
 23: required i32 maxColumnsInIndex,
 24: required i32 maxColumnsInOrderBy,
 25: required i32 maxColumnsInSelect,
 26: required i32 maxColumnsInTable,
 27: required i32 maxConnections,
 28: required i32 maxIndexLength,
 29: required i32 maxRowSize,
 30: required i32 maxStatementLength,
 31: required i32 maxOpenStatements,
 32: required i32 maxTableNamesInSelect,
 33: required i32 maxColumnNameLength,
 34: required i32 maxCursorNameLength,
 35: required i32 maxSchemaNameLength,
 36: required i32 maxProcedureNameLength,
 37: required i32 maxCatalogNameLength,
 38: required i32 maxTableNameLength,
 39: required i32 maxUserNameLength,
 40: required i32 defaultTransactionIsolation,
 41: required byte defaultResultSetType,
 42: required bool defaultResultSetHoldabilityHoldCursorsOverCommit,
 // if true then the SQLSTATEs returned by GFXDException are
 // X/Open (now known as Open Group) SQL CLI else they are SQL99
 43: required bool sqlStateIsXOpen,
 44: required bool catalogAtStart,
 45: required map<TransactionAttribute, bool> transactionDefaults,
 46: required RowIdLifetime rowIdLifeTime,
 47: required set<ServiceFeature> supportedFeatures,
 48: required map<ServiceFeatureParameterized, list<i32>> featuresWithParams
}

enum ServiceMetaDataCall {
  CATALOGS          = 1,
  SCHEMAS           = 2,
  TABLES            = 3,
  TABLETYPES        = 4,
  COLUMNS           = 5,
  TABLEPRIVILEGES   = 6,
  COLUMNPRIVILEGES  = 7,
  PRIMARYKEYS       = 8,
  IMPORTEDKEYS      = 9,
  EXPORTEDKEYS      = 10,
  CROSSREFERENCE    = 11,
  PROCEDURES        = 12,
  FUNCTIONS         = 13,
  PROCEDURECOLUMNS  = 14,
  FUNCTIONCOLUMNS   = 15,
  ATTRIBUTES        = 16,
  TYPEINFO          = 17,
  SUPERTYPES        = 18,
  SUPERTABLES       = 19,
  VERSIONCOLUMNS    = 20,
  CLIENTINFOPROPS   = 21,
  PSEUDOCOLUMNS     = 22
}

// constants for driver type
const byte DRIVER_JDBC = 1;
const byte DRIVER_ODBC = 2;

struct ServiceMetaDataArgs {
  1: required i32            connId,
  2: required byte           driverType,
  3: optional binary         token,
  4: optional string         schema,
  5: optional string         table,
  6: optional list<string>   tableTypes,
  7: optional string         columnName,
  8: optional string         foreignSchema,
  9: optional string         foreignTable,
 10: optional string         procedureName,
 11: optional string         functionName,
 12: optional string         attributeName,
 13: optional string         typeName,
 14: optional GFXDType       typeId
}

// constant for the default session token size used by security mechanisms
// like PLAIN and DIFFIE_HELLMAN
const i32 DEFAULT_SESSION_TOKEN_SIZE = 16;

enum SecurityMechanism {
  PLAIN = 1,
  DIFFIE_HELLMAN = 2
}

struct OpenConnectionArgs {
  1: required string clientHostName,
  2: required string clientID,
  3: required SecurityMechanism security,
  4: optional string userName,
  5: optional string password,
  // number of bytes to use for connection ID token
  // default is DEFAULT_SESSION_TOKEN_SIZE;
  // in future will be used for encryption of token etc. with
  // policy like in GFE client-server to defeat MIM attacks;
  // addition of the token argument allows for that expansion in future
  6: optional i32 tokenSize,
  7: optional bool useStringForDecimal,
  8: optional map<string, string> properties 
}

struct ConnectionProperties {
  1: required i32    connId,
  2: required string clientHostName,
  3: required string clientID,
  4: optional string userName,
  5: optional binary token
}

// enumeration of the various types of network services running in the system
// that are returned by "getPreferredServer" and similar API returning
// HostAddress that can be used by client to choose appropriate servers
// as per its own matching configuration
enum ServerType {
  // old DRDA servers
  DRDA = 1,

  // Thrift LocatorService using TCompactProtocol
  THRIFT_LOCATOR_CP = 2,
  // Thrift LocatorService using TBinaryProtocol
  THRIFT_LOCATOR_BP = 3,
  // Thrift LocatorService using TCompactProtocol over SSL
  THRIFT_LOCATOR_CP_SSL = 4,
  // Thrift LocatorService using TBinaryProtocol over SSL
  THRIFT_LOCATOR_BP_SSL = 5,

  // Thrift GFXDService using TCompactProtocol
  THRIFT_GFXD_CP = 6,
  // Thrift GFXDService using TBinaryProtocol
  THRIFT_GFXD_BP = 7,
  // Thrift GFXDService using TCompactProtocol over SSL
  THRIFT_GFXD_CP_SSL = 8,
  // Thrift GFXDService using TBinaryProtocol over SSL
  THRIFT_GFXD_BP_SSL = 9
}

struct HostAddress {
  1: required string hostName,
  2: required i32 port,
  3: optional string ipAddress,
  // optional since "failedServers" may not have this
  4: optional ServerType serverType
}

// exceptions
struct GFXDExceptionData {
  1: required string reason,
  2: required string sqlState,
  3: required i32 severity
}

exception GFXDException {
  1: required GFXDExceptionData exceptionData,
  2: required string serverInfo,
  3: optional list<GFXDExceptionData> nextExceptions
}

// default batch size
const i32 DEFAULT_RESULTSET_BATCHSIZE = 1024;
// default LOB chunk size
const i32 DEFAULT_LOB_CHUNKSIZE = 1048576; // 1MB

// constants for transaction isolation levels
const byte TRANSACTION_NONE = 0;
const byte TRANSACTION_READ_UNCOMMITTED = 1;
const byte TRANSACTION_READ_COMMITTED = 2;
const byte TRANSACTION_REPEATABLE_READ = 4;
const byte TRANSACTION_SERIALIZABLE = 8;
// special flag to indicate no change to current isolation level
const byte TRANSACTION_NO_CHANGE = 64;

// constant for the default transaction isolation
const byte DEFAULT_TRANSACTION_ISOLATION = TRANSACTION_NONE;

struct StatementAttrs {
  1: optional byte           resultSetType,
  2: optional bool           updatable,
  3: optional bool           holdCursorsOverCommit,
  4: optional bool           requireAutoIncCols,
  // requireAutoIncCols should be true for this to take affect
  5: optional list<i32>      autoIncColumns,
  // requireAutoIncCols should be true for this to take affect
  6: optional list<string>   autoIncColumnNames,
  7: optional i32            batchSize = DEFAULT_RESULTSET_BATCHSIZE,
  // absence means FETCH_UNKNOWN
  8: optional bool           fetchReverse,
  9: optional i32            lobChunkSize,
 10: optional i32            maxRows,
 11: optional i32            maxFieldSize,
 12: optional i32            timeout,
 13: optional string         cursorName,
 14: optional bool           possibleDuplicate,
 15: optional bool           poolable,
 16: optional bool           doEscapeProcessing,
 17: optional map<TransactionAttribute, bool> pendingTransactionAttrs
}

struct DateTime {
  1: required i64 secsSinceEpoch,
}

struct ColumnValue {
  1: optional bool          bool_val      // BOOLEAN
  2: optional byte          byte_val      // TINYINT
  3: optional i16           i16_val       // SMALLINT
  4: optional i32           i32_val       // INT
  5: optional i64           i64_val       // BIGINT
  // using 32-bit integer for FLOAT instead of double to avoid
  // any changes in presicion; callers must encode float as 32-bit integer
  6: optional i32           float_val     // FLOAT
  7: optional double        double_val    // DOUBLE
  8: optional string        string_val    // CHAR, VARCHAR, others
  9: optional Decimal       decimal_val   // DECIMAL/NUMERIC
 10: optional DateTime      date_val      // DATE (only the date portion is used)
 11: optional DateTime      time_val      // TIME (only the time portion is used)
 12: optional Timestamp     timestamp_val // TIMESTAMP
 13: optional binary        binary_val    // BINARY, VARBINARY
 14: optional BlobChunk     blob_val      // BLOB
 15: optional ClobChunk     clob_val      // CLOB
 16: optional bool          null_val      // NULL
 17: optional PDXObject     pdx_val,      // PDX object
 18: optional JSONObject    json_val,     // JSON object
 19: optional binary        java_val      // custom Java serialized object
}

// flags for ColumnDescriptor.descFlags field
// Defaults are:
//   READONLY, COLUMN_NULLABLE_UNKNOWN, NOT_AUTOINC, PARAMETER_MODE_UNKNOWN
const i16 COLUMN_UPDATABLE = 0x1;
const i16 COLUMN_DEFINITELY_UPDATABLE = 0x2;
const i16 COLUMN_NONULLS = 0x4;
const i16 COLUMN_NULLABLE = 0x8;
const i16 COLUMN_AUTOINC = 0x10;
const i16 PARAMETER_MODE_IN = 0x20;
const i16 PARAMETER_MODE_INOUT = 0x40;
const i16 PARAMETER_MODE_OUT = 0x80;

// constants for unknown precision/scale
const i16 COLUMN_PRECISION_UNKNOWN = 0;
const i16 COLUMN_SCALE_UNKNOWN = 0;
// max decimal precision supported by server
const i32 DECIMAL_MAX_PRECISION = 127;

struct ColumnDescriptor {
  1: required GFXDType type,
  2: required i16      descFlags,
  3: required i16      precision,
  4: optional i16      scale,
  5: optional string   name,
  6: optional string   fullTableName,
  7: optional string   udtTypeAndClassName
}

// constants for cursor update operation type
const byte CURSOR_UPDATE = 1;
const byte CURSOR_INSERT = 2;
const byte CURSOR_DELETE = 3;

struct Row {
  1: required list<ColumnValue>      values
}

struct OutputParameter {
  1: required GFXDType type,
  2: optional i32      scale,
  3: optional string   typeName
}

// If statementId returned is this value then the statement has already
// been closed.
// If cursorId for a RowSet is set this value, then it is already finished
// and no further operations are possible
const i32 INVALID_ID = 0;

// values for otherResultSetBehaviour flag of getNextResultSet
const byte NEXTRS_CLOSE_ALL_RESULTS = 0;
const byte NEXTRS_KEEP_CURRENT_RESULT = 1;
const byte NEXTRS_CLOSE_CURRENT_RESULT = 2;

// bitmasks for RowSet.flags
// if this is the last batch of rows for current result set
const byte ROWSET_LAST_BATCH = 1;
// for multiple result sets with CALL PROCEDUREs
const byte ROWSET_HAS_MORE_ROWSETS = 2;
// if all data for BLOB and CLOB columns has been already fetched
// and does not need to be obtained using LOB calls separately
const byte ROWSET_DONE_FOR_LOBS = 4;

struct RowSet {
  1: required list<Row>              rows,
  // bitmask flags as a combination of constants defined above
  2: required byte                   flags,
  // ID associated with this RowSet
  3: required i32                    cursorId,
  // ID of the associated statement
  4: required i32                    statementId,
  // three arguments below are used to fix the origin of this result
  // so client can detect failure cases easily when iterating over results
  // (token and address are optional and will not be set by server)
  5: required i32                    connId,
  6: optional binary                 token,
  7: optional HostAddress            source,
  // the starting row number (0-based) in case of batched results
  // this is set only for scrollable resultsets
  8: optional i32                    offset,
  // set in first call but not set in subsequent *scroll*() calls
  9: optional list<ColumnDescriptor> metadata,
 10: optional string                 cursorName,
 11: optional GFXDExceptionData      warnings,
  // when using an updatable query, these row IDs (in current batch) are
  // returned for SELECT FOR UPDATE statements or when StatementAttributes
  // indicates UPDATE in case table has no primary key
  // the row ID needs to be sent back to the server for cursor update/delete
  // else it will fail on server for the case when table has no primary key
 12: optional list<i64>              rowIdsForUpdateOrDelete
}

struct PrepareResult {
  1: required i32                    statementId,
  2: required list<ColumnDescriptor> parameterMetaData,
  3: optional list<ColumnDescriptor> resultSetMetaData,
  4: optional GFXDExceptionData      warnings
}

struct UpdateResult {
  // for single row updates
  1: optional i32                    updateCount,
  // for batch updates
  2: optional list<i32>              batchUpdateCounts,
  3: optional RowSet                 generatedKeys,
  4: optional GFXDExceptionData      warnings
}

struct StatementResult {
  // will be set to null in case there is no result set
  1: optional RowSet                 resultSet,
  // update count for DMLs else -1 if not applicable or unknown
  2: optional i32                    updateCount,
  // for batch updates in prepareAndExecute
  3: optional list<i32>              batchUpdateCounts,
  4: optional Row                    procedureOutParams,
  5: optional RowSet                 generatedKeys,
  6: optional GFXDExceptionData      warnings,
  // for prepareAndExecute
  7: optional PrepareResult          preparedResult
}

// type IDs for EntityId used by bulkClose API
const byte BULK_CLOSE_RESULTSET = 1;
const byte BULK_CLOSE_LOB = 2;
const byte BULK_CLOSE_STATEMENT = 3;
const byte BULK_CLOSE_CONNECTION = 4;

struct EntityId {
  1: required i32                    id,
  2: required byte                   type,
  3: required i32                    connId,
  4: optional binary                 token
}



service LocatorService {

  HostAddress getPreferredServer(
      // get a server from among given ServerTypes (union)
      1: set<ServerType> serverTypes,
      // get a server from among given server groups (union)
      2: set<string> serverGroups,
      3: set<HostAddress> failedServers) throws (1: GFXDException error)

  list<HostAddress> getAllServersWithPreferredServer(
      // get a server from among given ServerTypes (union)
      1: set<ServerType> serverTypes,
      // get a server from among given server groups (union)
      2: set<string> serverGroups,
      3: set<HostAddress> failedServers) throws (1: GFXDException error)

  oneway void closeConnection()
}



service GFXDService {

// following are copied from LocatorService since some language
// generators do not implement inheritence correctly

  HostAddress getPreferredServer(
      // get a server from among given ServerTypes (union)
      1: set<ServerType> serverTypes,
      // get a server from among given server groups (union)
      2: set<string> serverGroups,
      3: set<HostAddress> failedServers) throws (1: GFXDException error)

  list<HostAddress> getAllServersWithPreferredServer(
      // get a server from among given ServerTypes (union)
      1: set<ServerType> serverTypes,
      // get a server from among given server groups (union)
      2: set<string> serverGroups,
      3: set<HostAddress> failedServers) throws (1: GFXDException error)

// end LocatorService

  ConnectionProperties openConnection(1: OpenConnectionArgs arguments)
      throws (1: GFXDException error)

  StatementResult execute(1: i32 connId,
      2: string sql,
      // optional
      3: map<i32, OutputParameter> outputParams,
      // optional
      4: StatementAttrs attrs,
      // optional
      5: binary token) throws (1: GFXDException error)

  UpdateResult executeUpdate(1: i32 connId,
      2: list<string> sqls,
      // optional
      3: StatementAttrs attrs,
      // optional
      4: binary token) throws (1: GFXDException error)

  RowSet executeQuery(1: i32 connId,
      2: string sql,
      // optional
      3: StatementAttrs attrs,
      // optional
      4: binary token) throws (1: GFXDException error)

  PrepareResult prepareStatement(1: i32 connId,
      2: string sql,
      // optional
      3: map<i32, OutputParameter> outputParams,
      // optional
      4: StatementAttrs attrs,
      // optional
      5: binary token) throws (1: GFXDException error)

  StatementResult executePrepared(1: i32 stmtId,
      2: Row params,
      // optional
      3: map<i32, OutputParameter> outputParams,
      // optional
      4: binary token) throws (1: GFXDException error)

  UpdateResult executePreparedUpdate(1: i32 stmtId,
      2: Row params,
      // optional
      3: binary token) throws (1: GFXDException error)

  RowSet executePreparedQuery(1: i32 stmtId,
      2: Row params,
      // optional
      3: binary token) throws (1: GFXDException error)

  UpdateResult executePreparedBatch(1: i32 stmtId,
      2: list<Row> paramsBatch,
      // optional
      3: binary token) throws (1: GFXDException error)

  StatementResult prepareAndExecute(1: i32 connId,
      2: string sql,
      3: list<Row> paramsBatch,
      // optional
      4: map<i32, OutputParameter> outputParams,
      // optional
      5: StatementAttrs attrs,
      // optional
      6: binary token) throws (1: GFXDException error)

  void beginTransaction(1: i32 connId,
      2: byte isolationLevel,
      // optional
      3: map<TransactionAttribute, bool> flags,
      // optional
      4: binary token) throws (1: GFXDException error)

  void setTransactionAttributes(1: i32 connId,
      2: map<TransactionAttribute, bool> flags,
      // optional
      3: binary token) throws (1: GFXDException error)

  map<TransactionAttribute, bool> getTransactionAttributes(1: i32 connId,
      // optional
      2: binary token) throws (1: GFXDException error)

  void commitTransaction(1: i32 connId,
      2: bool startNewTransaction,
      // optional
      3: map<TransactionAttribute, bool> flags,
      // optional
      4: binary token) throws (1: GFXDException error)

  void rollbackTransaction(1: i32 connId,
      2: bool startNewTransaction,
      // optional
      3: map<TransactionAttribute, bool> flags,
      // optional
      4: binary token) throws (1: GFXDException error)

  // returns true if second phase commitTransaction() is required else
  // false where commit was single-phase (e.g. for READ_ONLY transaction)
  bool prepareCommitTransaction(1: i32 connId,
      // optional
      2: map<TransactionAttribute, bool> flags,
      // optional
      3: binary token) throws (1: GFXDException error)

  RowSet getNextResultSet(1: i32 cursorId,
      2: byte otherResultSetBehaviour,
      // optional
      3: binary token) throws (1: GFXDException error)

  BlobChunk getBlobChunk(1: i32 connId,
      2: i32 lobId,
      3: i64 offset,
      4: i32 size,
      // if true then free the server-side handle to blob when last==true
      5: bool freeLobAtEnd,
      // optional
      6: binary token) throws (1: GFXDException error)
  ClobChunk getClobChunk(1: i32 connId,
      2: i32 lobId,
      3: i64 offset,
      4: i32 size,
      // if true then free the server-side handle to blob when last==true
      5: bool freeLobAtEnd,
      // optional
      6: binary token) throws (1: GFXDException error)

  i32 sendBlobChunk(1: BlobChunk chunk,
      2: i32 connId,
      // optional
      3: binary token) throws (1: GFXDException error)
  i32 sendClobChunk(1: ClobChunk chunk,
  	  2: i32 connId,
      // optional
      3: binary token) throws (1: GFXDException error)

  void freeLob(1: i32 connId,
      2: i32 lobId,
      // optional
      3: binary token) throws (1: GFXDException error)

  // cursor operations

  RowSet scrollCursor(1: i32 cursorId,
      2: i32 offset,
      3: bool offsetIsAbsolute,
      4: bool fetchReverse,
      5: i32 fetchSize,
      // optional
      6: binary token) throws (1: GFXDException error)

  void executeCursorUpdate(1: i32 cursorId,
      2: list<byte> operations,
      3: list<Row> changedRows,
      4: list<list<i32>> changedColumnsList,
      // optional
      5: list<i32> changedRowIndexes,
      // optional
      6: binary token) throws (1: GFXDException error)

  // meta-data API

  ServiceMetaData getServiceMetaData(1: i32 connId,
      // optional
      2: binary token) throws (1: GFXDException error)

  RowSet getSchemaMetaData(1: ServiceMetaDataCall schemaCall,
      2: ServiceMetaDataArgs metadataArgs) throws (1: GFXDException error)

  RowSet getIndexInfo(1: ServiceMetaDataArgs metadataArgs,
      2: bool unique,
      3: bool approximate) throws (1: GFXDException error)

  RowSet getUDTs(1: ServiceMetaDataArgs metadataArgs,
      2: list<GFXDType> types) throws (1: GFXDException error)

  RowSet getBestRowIdentifier(1: ServiceMetaDataArgs metadataArgs,
      2: i32 scope,
      3: bool nullable) throws (1: GFXDException error)

  // end meta-data API

  list<ConnectionProperties> fetchActiveConnections(1: i32 connId,
      // optional
      2: binary token) throws (1: GFXDException error)
  map<i32, string> fetchActiveStatements(1: i32 connId,
      // optional
      2: binary token) throws (1: GFXDException error)

  void cancelStatement(1: i32 stmtId,
      // optional
      2: binary token) throws (1: GFXDException error)

  void closeResultSet  (1: i32 cursorId,
      // optional
      2: binary token) throws (1: GFXDException error)
  void closeStatement  (1: i32 stmtId,
      // optional
      2: binary token) throws (1: GFXDException error)
  oneway void closeConnection (1: i32 connId,
      // optional
      2: binary token)

  oneway void bulkClose(
      // IDs of entities to be closed (ResultSet, LOB, Statement or Connection)
      1: list<EntityId> entities)
}
